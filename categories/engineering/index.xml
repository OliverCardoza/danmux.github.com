<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Engineering on Dans Stuff</title>
    <link>http://danmux.com/categories/engineering/</link>
    <description>Recent content in Engineering on Dans Stuff</description>
    <generator>Hugo -- gohugo.io</generator>
    
    
    
    
    <lastBuildDate>Wed, 17 Aug 2016 00:00:00 UT</lastBuildDate>
    <atom:link href="http://danmux.com/categories/engineering/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>What Golang Is and Is Not</title>
      <link>http://danmux.com/posts/what_golang_isnt/</link>
      <pubDate>Wed, 17 Aug 2016 00:00:00 UT</pubDate>
      
      <guid>http://danmux.com/posts/what_golang_isnt/</guid>
      <description>

&lt;p&gt;We are all products of our own histories, and I suspect many routes to Go have been made less enjoyable by misguided expectations. The journey from when a budding developer first &amp;lsquo;hello worlded’ to now may have made Go&amp;rsquo;s more subtle strengths less obvious to them.&lt;/p&gt;

&lt;p&gt;Go is least of all about the language in and of itself, but rather about the broader things affected by it, more so than other languages I have used over the years.&lt;/p&gt;

&lt;p&gt;Many recent arrivals to Go have preconceptions that have been proved wrong and caused disappointment, this appears to happen most often when looking from a more purist computer science based language design point of view.&lt;/p&gt;

&lt;p&gt;Go is an engineering tool, in a much broader sense. To appreciate it properly I think you have to have spent a decent amount of time responsible for the full lifecycle. If all you ever do is write and commit code then much of Go will be lost on you.&lt;/p&gt;

&lt;h2 id=&#34;the-go-hype-or-not:6f23aa5cf001e206affe126e84fac8b3&#34;&gt;The Go Hype, or Not.&lt;/h2&gt;

&lt;p&gt;I have heard more than once that people have been disappointed by go given the &lt;em&gt;hype&lt;/em&gt; surrounding it. I don’t remember anything really hype like 5 years ago when go was in its infancy, and I must say that I am not really aware of anything specific now. Of course any new language that is becoming better adopted, in particular as quickly as Go, will naturally attract attention.&lt;/p&gt;

&lt;p&gt;There are articles out there that sing Go&amp;rsquo;s praises, perhaps a little too highly, but I don&amp;rsquo;t remember many of them explicitly making any claims about the &lt;em&gt;language&lt;/em&gt; itself being the reason why Go is so good.&lt;/p&gt;

&lt;h2 id=&#34;go-is-not-an-innovative-language:6f23aa5cf001e206affe126e84fac8b3&#34;&gt;Go is Not An Innovative Language&lt;/h2&gt;

&lt;p&gt;&amp;ldquo;Innovative&amp;rdquo; is such an overused and abused word that it has lost a lot of power and meaning. All innovation is contextual and to use the word without context is foolhardy. In the context of language design Go was never an innovative language, nor was it presented as such, or anyone dishonest in representing it that way.&lt;/p&gt;

&lt;p&gt;As a language Go was always explicitly a return to simplicity, and in many ways naivety, for sound reasons.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;There is nothing new under the sun&amp;rdquo; rings true in all languages since the 80&amp;rsquo;s. Virtually everything we see in language design now that someone says is &amp;ldquo;innovative&amp;rdquo; has been explored in some form before. Go is certainly no exception, but remember it never claimed to be state of the art.&lt;/p&gt;

&lt;p&gt;Regarding the language being youthful, of course it is, but the intention is not for the language itself to &amp;lsquo;mature&amp;rsquo;: no more complexity is going to be added, or at least it&amp;rsquo;s very unlikely. It is not &amp;lsquo;missing&amp;rsquo; comprehensions, or inheritance, or generics, they are &lt;strong&gt;omitted&lt;/strong&gt; (and I pray, always will be). In some way, in the context of the current fashion of returning to more functional languages, or the evolution of good old languages to include more functional paradigms (I&amp;rsquo;m looking at you Javascript and Python for two examples) then in a tenuous convoluted way Go has &amp;lsquo;innovated&amp;rsquo; by avoiding that trend.&lt;/p&gt;

&lt;h2 id=&#34;go-is-an-innovative-thing:6f23aa5cf001e206affe126e84fac8b3&#34;&gt;Go is an Innovative Thing&lt;/h2&gt;

&lt;p&gt;It is hard to define what the &amp;lsquo;thing&amp;rsquo; is, but it is quite a broad thing, I can&amp;rsquo;t fully say it is an approach, or a belief, or even &amp;lsquo;patterns and practices&amp;rsquo;, though that last phrase feels closest. This is still about the best read on the subject: &lt;a href=&#34;https://talks.golang.org/2012/splash.article&#34;&gt;Go at Google: Language Design in the Service of Software Engineering&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Possibly Go&amp;rsquo;s greatest &amp;lsquo;innovation&amp;rsquo; is to eschew making software engineering an overly academic process in daily practice, and to focus on improving the tools, speed, reliability and pure pleasure in &lt;strong&gt;delivering&lt;/strong&gt; and running things of value.&lt;/p&gt;

&lt;h3 id=&#34;unifying:6f23aa5cf001e206affe126e84fac8b3&#34;&gt;Unifying&lt;/h3&gt;

&lt;p&gt;I think one reasonable way of categorising all the things that make up delivering software products is into: &lt;em&gt;human&lt;/em&gt;, &lt;em&gt;operational&lt;/em&gt; and &lt;em&gt;technology&lt;/em&gt; factors, in that order of value. Go helps address some problems in all three areas but it is its influence over human and operational factors where it sets itself apart from other systems.&lt;/p&gt;

&lt;p&gt;Even as technologists we can&amp;rsquo;t help moving things into the &amp;lsquo;human&amp;rsquo; domains such as emotion and personalisation, most compilers don&amp;rsquo;t care about many of the things humans care about, but the language naturally becomes a very human thing.&lt;/p&gt;

&lt;p&gt;Go has learned from the experience of fractured communities and continual in-fighting amongst teams and has attempted to avoid debates that continue to rage in other languages that are 20+ years old. The early focus on idioms helped that. This approach comes from years of experience delivering in teams at scale, where the language is one small factor, which has caused an inappropriate amount of time wasted on a tiny fraction of the whole value. As an example: curly brace positioning is one of the most trivial things possible, and yet still many hours are wasted on it.&lt;/p&gt;

&lt;h3 id=&#34;paradox-of-choice:6f23aa5cf001e206affe126e84fac8b3&#34;&gt;Paradox of Choice&lt;/h3&gt;

&lt;p&gt;In all languages there are always some basic primitives and data types that relate closely to the machine instruction set, which in turns map well to the hardware (see Note 1.) Ultimately all other higher order data structures in all languages are composed of arrays, references, and structs. Trees, heaps, sets, queues and everything else effectively only manipulate arrays of structs/primitives or self referencing structs, thats it, simple, or it should be.&lt;/p&gt;

&lt;p&gt;In the Go language at its heart that simplicity is encouraged, we are only offered some basics. To start with we are given primitives, structs and arrays, then because it is unavoidably useful we have a dynamic array, a slice which is an embellished array to allow dynamic resizing. Finally, in certain problem domains the power and flexibility of a hash-map is also unavoidable, therefore Go provides a Map built in.&lt;/p&gt;

&lt;p&gt;There is a subtlety to providing only this subset. The fact they map well to lower layers imbues an immediate sense of being closer to the metal, which certainly for &amp;lsquo;older&amp;rsquo; engineers feels refreshing, and at a minimum for younger engineers tends to influence design decisions towards simplicity. Having said that the desire to construct complex implementations of data structures - even if used only once - is ever present when a new arrival to Go finds their favourite container is &amp;lsquo;missing&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;To provide any solution in Go that needs a dynamic data structure you can choose between hand rolled linked structures or a &lt;code&gt;Slice&lt;/code&gt; or &lt;code&gt;Map&lt;/code&gt; (or compose with them). As they are quite different the choice is normally obvious. Contrast this to the choice between map, set, hashset, bag etc etc, or rolling your own in a language that makes this a lot harder. Often the author actually only uses a subset of the functionality of those data structures. In these cases the choice becomes much less simple, indeed often a point of confusion and contention and can be the cause of further low-value conversations.&lt;/p&gt;

&lt;p&gt;A Go programmer takes a slice or map and mixes in a few functions to provide the structure they need. For example The Go standard library has provided a minimal &lt;code&gt;container&lt;/code&gt; package with a &lt;code&gt;heap&lt;/code&gt; (which is just an interface), a &lt;code&gt;list&lt;/code&gt; (doubly linked), and a &lt;code&gt;ring&lt;/code&gt; (which is a closed doubly linked list).  To implement a heap - you need to provide a builtin to implement the storage with an array being the typical choice.&lt;/p&gt;

&lt;p&gt;Each one of those packages has no more than around 200 lines of code. Those few lines of code are very readable, the behaviour understandable, and the performance predictable; being a function of the performance of the well understood builtin and the users own implementation code.&lt;/p&gt;

&lt;p&gt;This removal of choice and focus on reusing the two builtins, drives a readability, clarity and consistency amongst Go programmers, not afforded in other languages.&lt;/p&gt;

&lt;p&gt;In other languages an iterator (one of the often complained about omissions) necessarily abstracts that which is being contained, and often insists on a broad interface some of which then remains unused, and adds some cognitive load, sometimes unnecessarily.  Not providing an iterator and not providing many containers implementing iterable, or whatever other system, avoids needing a whole swathe of knowledge, indirection, discussion and misunderstanding, at little real world cost.&lt;/p&gt;

&lt;p&gt;The effect of the omission in real world code results in minimal extra work at code creation time, for great gains in the rest of the lifecycle. Custom data structures can be composed from the well understood builtins, rolled in under 100 lines of code and can can exist close to the place they are used (yes repeated!). The effect of this approach on readability, maintainability, decoupling, removing seemingly endless low value conversations, and when push comes to shove the ability to understand performance characteristics and then tune them, adds so much more value to the whole lifecycle, than the cost of the omission.&lt;/p&gt;

&lt;p&gt;These are subtle yet important factors that attempt to address some of the human and operational complications.&lt;/p&gt;

&lt;h2 id=&#34;more-than-a-language:6f23aa5cf001e206affe126e84fac8b3&#34;&gt;More Than a Language&lt;/h2&gt;

&lt;p&gt;Without going into all of the things that the Go ecosystem brings to the table on top of the language design, what should be clear from a shallow familiarity with the tooling is that Go has focussed on providing answers to some of the more difficult aspects of actually getting code that is both stable and agile into production. These things that were part of Go from the beginning have had to evolve over decades in other languages, often in fractured directions - again adding the paradox of choice. For example Go&amp;rsquo;s dependancy management attempts to solve a thorny problem, and while &lt;code&gt;go get&lt;/code&gt; in particular is going through some teething pains, its inclusion from day one is illustrative of Go’s intention.&lt;/p&gt;

&lt;p&gt;It is this focus on the operational aspects of development, so early on in Go&amp;rsquo;s evolution that emphasises the reason Go was created, and is commonly overlooked in favour of low value critiques of the language itself.&lt;/p&gt;

&lt;h3 id=&#34;note-1:6f23aa5cf001e206affe126e84fac8b3&#34;&gt;Note 1.&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;In our Von Neumann world we have basically three hardwired data structures, a register, a stack, and addressable memory, these are mapped via the instruction set to: register operations; effectively push and pop, moving data to and from memory addresses, and in CISC&amp;rsquo;s contiguous memory operations, even in RISC&amp;rsquo;s loop primitives are optimised for contiguous ranges. Ultimately these in turn map through compilers to value variables (which indirect the decision to use registers, the stack, or an addressable value), and reference variables, which contain the value of an address of the value, and slightly higher up the conceptual scale: arrays. Compilers also compose these fundamental variables into primitive data types: ints, floats, and arrays into strings etc. Finally, also through well managed contiguous memory, namely &amp;lsquo;packing’, common primitives are grouped into &amp;lsquo;structs&amp;rsquo;. There are subtle variations on these themes, particularly with respect to structs or objects, involving further indirection (think v-tables etc), but that is the crux of it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Test Pyramid and Availability Bias</title>
      <link>http://danmux.com/posts/test_pyramid_availability_bias/</link>
      <pubDate>Mon, 21 Dec 2015 00:00:00 UT</pubDate>
      
      <guid>http://danmux.com/posts/test_pyramid_availability_bias/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid&#34;&gt;The test pyramid&lt;/a&gt; has its place - it gets across a simple idea, but it has been taken too literally, and applied innapropriately.&lt;/p&gt;

&lt;h2 id=&#34;the-pyramid-and-dificult-compromises:f9c27430fb20a304ea9dd81fcf7df4c9&#34;&gt;The Pyramid and Dificult Compromises&lt;/h2&gt;

&lt;p&gt;My understanding of Cohns original article was that people too often downplay the service or integration tests, and I think discussions of the pyramid miss this emphasis, and have focused too much on the Pyramid itself.&lt;/p&gt;

&lt;p&gt;Unit vs X Tests (where X = any name for anything other than Unit)  must be the most tiresome debate ever in the history of software development. Over the years I have often found myself encouraging and sometimes justifying my compromises. My arguments have never been devastatingly good, because like any engineering there are often many good enough ways to achieve the desired outcome.&lt;/p&gt;

&lt;p&gt;&amp;lsquo;Good enough&amp;rsquo; is at the heart of all engineering. Good enough to manage the risks with just enough confidence. From past experience I have, in general, found that developers from a computer science background sometimes struggle with &amp;lsquo;engineering compromise&amp;rsquo; more than those from an engineering background.&lt;/p&gt;

&lt;p&gt;Judging good enough and risk is hard and takes confidence and experience to get the balance right in the many different projects and products we work within. A set of tried and tested prescriptions is always more straight forward.&lt;/p&gt;

&lt;h2 id=&#34;the-base-of-the-pyramid-problem:f9c27430fb20a304ea9dd81fcf7df4c9&#34;&gt;The Base of the Pyramid Problem&lt;/h2&gt;

&lt;p&gt;It is way too prescriptive:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It oversimplifies the situation, so it is used as a crutch to avoid critical thinking (notice I avoided the phrase containing the word &amp;lsquo;cargo&amp;rsquo;). How often would 70:20:10 be perfect for your situation.&lt;/li&gt;
&lt;li&gt;The top of the pyramid refers explicitly to GUI based tests, often irrelevant, often the people who mention it forget this. (However, even a testing trapezoid would still be wrong)&lt;/li&gt;
&lt;li&gt;True user testing is completely ignored - experience - emotion - engagement (Dare I say quality as &lt;a href=&#34;https://en.wikipedia.org/wiki/Zen_and_the_Art_of_Motorcycle_Maintenance&#34;&gt;Persig&lt;/a&gt; defines it &amp;ldquo;Quality is the knife-edge of experience, found only in the present, known or at least potentially accessible to all of us&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;It is based on the false assumption that integration tests are slow and flaky, they can be as fast and robust as unit tests.&lt;/li&gt;
&lt;li&gt;It is 4 years old - the world has turned. Modern GUI&amp;rsquo;s (think Mobile and &lt;a href=&#34;https://en.wikipedia.org/wiki/Single-page_application&#34;&gt;SPA&lt;/a&gt;) are almost always cleanly divided by a well defined API. (if not then it&amp;rsquo;s not a testing problem, but a design problem)&lt;/li&gt;
&lt;li&gt;It downplays the relevance of boundary interactions, particularly during concurrency.&lt;/li&gt;
&lt;li&gt;Unit tests are subject to availability bias - and take on an inflated importance because of it.&lt;/li&gt;
&lt;li&gt;Unit tests themselves are a kind of availability bias - because they are easy to write and run they are used in the place of a more difficult, more complex, more valuable strategy, one that only becomes clear when you critically assess the real risks affecting quality.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;an-illustration-of-broken-thinking:f9c27430fb20a304ea9dd81fcf7df4c9&#34;&gt;An Illustration of Broken Thinking&lt;/h2&gt;

&lt;p&gt;The article most cited to me is the well read &lt;a href=&#34;http://martinfowler.com/bliki/TestPyramid.html&#34;&gt;Test Pyramid&lt;/a&gt; by Martin Fowler which references the original Mike Cohn article, &lt;a href=&#34;https://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid&#34;&gt;The Forgotten Layer of the Test Automation Pyramid&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Martins post links to another well known supporting article from the Google Testing Blog with the deliberately captivating title&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://googletesting.blogspot.ch/2015/04/just-say-no-to-more-end-to-end-tests.html&#34;&gt;Just Say No to More End-to-End Tests&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Which captures the narrow experiences and environment of one setup with some fundamental problems. Some parts of that Google testing blog post I simply did not fully understand until a few re-reads, and even then I was left questioning the validity of what I read. I felt it sounded outdated, and was based on some strange assumptions, it appears I am not alone.&lt;/p&gt;

&lt;p&gt;A counterpoint is posted on Martin’s post, which is also worth reading: &lt;a href=&#34;https://www.symphonious.net/2015/04/30/making-end-to-end-tests-work/&#34;&gt;Making End-to-End Tests Work&lt;/a&gt; which succinctly points out some limitation of the test system mentioned in the Google testing blog post above&amp;hellip;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;If your idea of fantastic test infrastructure starts with the words “every night” and ends with an email being sent you’re doomed&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The Google post is further analytically &lt;a href=&#34;http://bryanpendleton.blogspot.com.au/2015/04/on-testing-strategies-and-end-to-end.html?m=1&#34;&gt;dismembered here&lt;/a&gt;, and this article captures my own confusion well&amp;hellip;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Whatever went wrong with this project, though, one thing is very clear to me:&lt;/p&gt;

&lt;p&gt;The testing strategy is not the problem here.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;detail-of-availability-bias:f9c27430fb20a304ea9dd81fcf7df4c9&#34;&gt;Detail of Availability Bias&lt;/h2&gt;

&lt;p&gt;(my own pseudo science - feel free to skip to next section (but there is mention of interesting work in any case))&lt;/p&gt;

&lt;p&gt;Recently I have been reading a fascinating book that has long been on my to-read list: &lt;a href=&#34;http://www.amazon.co.uk/Thinking-Fast-Slow-Daniel-Kahneman/dp/0141033576&#34;&gt;Kahneman&amp;rsquo;s Thinking Fast and Slow&lt;/a&gt;. Fortuitously Kahneman has gifted me another tool in my arsenal against the over valuing of unit tests. Availability bias.&lt;/p&gt;

&lt;p&gt;The over importance of unit testing may just be down to availability bias.&lt;/p&gt;

&lt;p&gt;When I analyse the past encounters over the issue of unit testing vs other types of testing, I suspect this bias (or availability heuristic as it is also known) may be the main factor that tips the balance in favour of unit tests and has resulted in them appearing to be so important.&lt;/p&gt;

&lt;p&gt;Whilst I can&amp;rsquo;t do the book justice here, I&amp;rsquo;ll try and capture the salient points. Availability bias is an example of many evolutionary shortcuts in the human mind that can substitute a simple emotional decision for an otherwise difficult complex one, and has been demonstrated in many, brilliant, simple psychological experiments.&lt;/p&gt;

&lt;p&gt;In particular, according to Kahneman, Norbert Schwarz showed the paradox that we are less confident in our decision when asked to come up with more reasons why it is a good decision. Our brains make an overconfident emotional decision when we can immediately produce a few supporting reasons, and a less confident decision, when forced to think harder. This is one of those paradoxes which are obvious when pointed out.&lt;/p&gt;

&lt;p&gt;The book goes onto describe some related effects, regarding risk, which triggered my connection with testing, because I think much more in terms of risk than of test type, or test metric. Research by Paul Slovic, Sarah Lichtenstein and Baruch Fischhoff Showed that scientists opinions on the benefits of a particular technology could be increased by downplaying the risks, and similarly that the perception of the risks of a technology would be decreased, just by describing the benefits.&lt;/p&gt;

&lt;p&gt;It is clear how this emotional bias can be applied to software testing:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A lack of unit tests most often described as (and can be) a risk - therefore the benefits of unit tests are exaggerated in our minds.&lt;/li&gt;
&lt;li&gt;We can quickly recall a few examples of people who repeat the advantages of unit tests, and quickly recall a few personal experiences that support their advantage so the risks of focussing on them are downplayed.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is all based in normal animal survival laziness - it takes energy for our deep thinking brain to engage.&lt;/p&gt;

&lt;p&gt;A more direct consequence of our natural laziness also has a different type of biasing effect on the increased value attributed to unit testing.&lt;/p&gt;

&lt;p&gt;It is hard for anyone deeply embedded in a development team to truly know how valuable the team is, or, where necessary, how valuable individual members of the team are, or even how good the product is. The situation has developed where the very people responsible for the success of a development team are some of the least likely to be able to make an objective decision. Under these conditions it is easy to see how &amp;lsquo;measurement&amp;rsquo; is needed, it is this natural laziness that allows easy measurements to become so influential.&lt;/p&gt;

&lt;p&gt;Unit tests are easy, and the quick visibility they afford in the form of the second most harmfull metric in development - coverage, creates something measurable. This is an easy metric, and when coupled with the biases of 1 and 2 above it is easy to see how unit testing and test coverage take on a an overly exaggerated value. Perhaps most often outside of the team who writes the tests.&lt;/p&gt;

&lt;p&gt;I also think it is likely that we are still suffering the rebound from 10 years ago when test automation and unit testing were much less an integral part of the development cycle. The easiest goto tool in the interim has been the unit test.&lt;/p&gt;

&lt;h2 id=&#34;the-smart-way:f9c27430fb20a304ea9dd81fcf7df4c9&#34;&gt;The Smart Way&lt;/h2&gt;

&lt;p&gt;Whilst this post actually started out as a document of my linking availability bias with the over emphasis on unit testing and was not meant to be about the value of various tests in practice, it is probably clear that I encourage a more individually considered approach, than a set of prescribed rules.&lt;/p&gt;

&lt;p&gt;I want to make it clear that I totally understand that there are loads of cases, particularly on the computer science focussed side of development where unit tests are essentially the only sensible test strategy. But they are only one part of the package, and often a small part.&lt;/p&gt;

&lt;p&gt;In this article: &lt;a href=&#34;http://www.joecolantonio.com/2015/12/09/why-the-testing-pyramid-is-misleading-think-scales/&#34;&gt;Why the Testing Pyramid is Misleading&lt;/a&gt; the author discusses Todd Gardners (TrackJs) views which could be concieved to be indirectly addressing availability bias of unit tests, by making the point that we tend to not think in terms of risk. This article resonates strongly with my own approach to quality (again where quality is typically a bigger thing than that which we normally test for)&lt;/p&gt;

&lt;p&gt;That article references the video offering very sensible advice from Todd Gardner, Software Engineer and Entrepreneur at TrackJS, namely think critically&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://vimeo.com/144684986&#34;&gt;Case Studies in Terrible Testing&lt;/a&gt;
(slide deck &lt;a href=&#34;http://www.slideshare.net/todd3091/case-studies-in-terrible-testing&#34;&gt;here&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Especially salient is the advice from 25 minutes on, though this picture of the relative importance of different testing to mitigate the scale of the risks to the success of one particular project should illustrate the main thrust of the presentation&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/-uyf9z1SiSgw/Vnft1EYuFaI/AAAAAAAAMlQ/j_PQhbHL-jI/w1167-d-h870-p-rw&#34; alt=&#34;testing scales&#34; title=&#34;Testing Scales&#34; /&gt;

&lt;em&gt;Figure 1. A custom set of sliding scales of differing test strategies&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;When we truly think about how we can best reduce the risk to success, and use alternative appropriate tools to manage that risk we start to focus more on delivering real value.&lt;/p&gt;

&lt;p&gt;Monitoring, CD, and a real understanding of the users perceived value or quality through canary code, A/B testing and the like will have a much bigger impact than 70% coverage.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Fast to fix is almost as good as never broken (and sometimes better)&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;(from Todd’s slides above)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The ‘scales of risk’ metaphor is much more intelligent and appropriate than the pyramid. The pyramid is one combination of the risk scales which may well align with a correct assignment of risk in a minority of real world cases (as would the ice cream cone). Though as far as I remember, not on any projects I have worked on.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>