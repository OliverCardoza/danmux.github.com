<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dans Stuff</title>
    <link>http://danmux.com/categories/golang/index.xml</link>
    <description>Recent content on Dans Stuff</description>
    <generator>Hugo -- gohugo.io</generator>
    <atom:link href="http://danmux.com/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>The Cult of Go Test</title>
      <link>http://danmux.com/posts/the_cult_of_go_test/</link>
      <pubDate>Sun, 30 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://danmux.com/posts/the_cult_of_go_test/</guid>
      <description>&lt;p&gt;A favourite test helper library, with some simple test assertion functions clearly has some value. But this post puts forward some useable concrete arguments why they are normally just not worth it.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;After five years with Go and the last three in a (now) 100% Go team I&amp;rsquo;ve worked with around 30 Go developers - not a huge amount, but not insignificant. The one thing that new people to the team challenge most is the lack of their favorite test helpers. People generally are OK that we don&amp;rsquo;t need a whole framework, but the small simple assertions? Why are they so bad?&lt;/p&gt;

&lt;h2 id=&#34;tl-dr&#34;&gt;tl;dr&lt;/h2&gt;

&lt;p&gt;They are not so bad, but they come at a cost, defer to avoid them.&lt;/p&gt;

&lt;h2 id=&#34;three-reactions&#34;&gt;Three Reactions&lt;/h2&gt;

&lt;p&gt;This came up again recently and as I prepared to put forward the case against assert libs a learned colleague reminded me that this is still a case of bike-shedding. So if like us you have bigger problems, park this, and focus on them. However I&amp;rsquo;m putting pen to paper so I can point people at it in future, and it may help others. At first this recent tweet from @KentBeck first felt relevant:&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;en&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Don&amp;#39;t spend more time discussing a reversible change than it would take to make (&amp;amp; potentially reverse) the change&lt;/p&gt;&amp;mdash; Kent Beck (@KentBeck) &lt;a href=&#34;https://twitter.com/KentBeck/status/792911449249026048&#34;&gt;October 31, 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;But then actually once you have &lt;code&gt;assert.Equals&lt;/code&gt; dotted throughout the tests the cost of removing it becomes unaffordable. Once you commit to one of the assertion libs it becomes hard to reverse that change. In that respect it is an expensive decision.&lt;/p&gt;

&lt;p&gt;Perhaps it was somewhat lucky that when I started writing Go code that no assertion libs existed, so I was forced to learn to live without them (I had been working with python and Java most recently prior to that) I felt the same surprise then as people do now! Years ago when &lt;code&gt;testify&lt;/code&gt; was young, I immediately started using it. It was only then as I had to learn how it worked, and work round its bugs and surprises, that I first came to think that perhaps my last 10+ years of unit testing had been overly complicated. (I expect there are many developers who don&amp;rsquo;t remember any of the xUnits existing - when each new project needed time to write the test harness or at least copying in some previous &lt;a href=&#34;http://www.martinfowler.com/bliki/Seedwork.html&#34;&gt;seedwork&lt;/a&gt; as Fowler called it. At the time jUnit felt like a godsend.&lt;/p&gt;

&lt;p&gt;This repeating conversation with engineers new to the team (or new to the stdlib only approach) could be grouped into one of three catagories of response:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interesting&lt;/strong&gt; - I&amp;rsquo;ve always felt a bit uneasy about the need for all this extra stuff - lets give this a go.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Really&lt;/strong&gt; - I&amp;rsquo;m pretty sure its going to be worse without the test lib/framework (dsl) im used to - but lets see if im right.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;What!&lt;/strong&gt; - thats just ignoring all the other testing stuff that happened in other things and is almost certainly a retrograde step.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There is a subtly different class of response for people who have been using Go for a while and have already chosen one of the test helper libraries, and have not yet &lt;em&gt;tried&lt;/em&gt; plain go test. When I say &lt;em&gt;&amp;lsquo;tried&amp;rsquo;&lt;/em&gt; I mean actually stuck with it for a few months - not wrote some plain tests in the first few weeks and immediately added a familiar looking assertion lib.&lt;/p&gt;

&lt;p&gt;In all three cases most people will give it some open minded time and form an opinion based on their now real world experience. In general people start to at least get comfortable with, if not actually value, the approach. During this time when a bit of effort is expended on learning a few of these tips the adoption is improved.&lt;/p&gt;

&lt;p&gt;In the worse case even after working with plain go test, some developers really struggle to understand or accept why they should not use their choice of helpers, occasionally attempting to sway opinion by challenging the intelligence and integrity of the team with accusations of cult like behaviour (cargo or otherwise). &amp;ldquo;Kool-aid&amp;rdquo; gets mentioned more than once. It will take a greater depth of argument than that to challenge this new (or retrograde, depending on your stance) well considered approach. From having spoken to team members and other teams and at conferences and from lots of stuff online it is clear that I am not alone in having thought about this a lot.&lt;/p&gt;

&lt;p&gt;This poll is possibly not great quality, and almost certainly somewhat self selecting but illustrates that at least some folk also prefer plain go test according to this &lt;a href=&#34;http://www.strawpoll.me/1716206/r&#34;&gt;Straw Poll&lt;/a&gt;&lt;/p&gt;

&lt;iframe src=&#34;http://www.strawpoll.me/embed_1/1716206/r&#34; style=&#34;width:680px;height:541px;border:0;&#34;&gt;Loading poll...&lt;/iframe&gt;

&lt;h2 id=&#34;not-such-a-big-thing&#34;&gt;Not Such a Big thing&lt;/h2&gt;

&lt;p&gt;(but it feels like it is fundamental!)&lt;/p&gt;

&lt;p&gt;It really isn&amp;rsquo;t such a big deal in any case, either way is OK, each team should make the call, but once it has been made it should be kept consistent. The mix of both plain go and assertions libs - clearly dilutes the benefits of consistency, particularly if multiple helper libs are added.&lt;/p&gt;

&lt;p&gt;Without doubt assertions can reduce verbosity in the tests, but as the code samples below will demonstrate when the stdlib tests are well written there is not that much in it. Clearly typing effort is not the final arbiter (by any means) in assessing the best approach, but it an important factor. There are other good, if subtle, reasons to stick with plain go test even if it may take more effort.&lt;/p&gt;

&lt;p&gt;Before looking at some specific examples of how stdlib tests compete well with assertion libraries (on various factors including effort) here are the bare minimum things to have read that start to explain the position.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/doc/faq#testing_framework&#34;&gt;https://golang.org/doc/faq#testing_framework&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/doc/faq#assertions&#34;&gt;https://golang.org/doc/faq#assertions&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s worth hearing the reason for Blake Mizerany (of Sinatra fame) to do this..&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://danmux.com/img/just-use-stdlib.png&#34; alt=&#34;Blake sees the light&#34; title=&#34;just use stdlib&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Explained in this presentation&amp;hellip;&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/yi5A3cK1LNA&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2 id=&#34;real-world-example&#34;&gt;Real World Example&lt;/h2&gt;

&lt;p&gt;Here is some real world test code that tends to favour an assertion library as there are only two fixtures to test a single function.&lt;/p&gt;

&lt;p&gt;The test was initially written with &lt;a href=&#34;https://github.com/stretchr/testify&#34;&gt;testify&lt;/a&gt; :&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/danmux/cbe74e643538bb0ff9c2bf78511d630e.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&amp;hellip;A compact 25 lines and 529 chars typed.&lt;/p&gt;

&lt;p&gt;This was then rewritten in plain go test in a very imperative style&amp;hellip;&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/danmux/64b4c47b2b25676adb7b3c18ac6193ac.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&amp;hellip;41 lines, but only 646 Chars typed - just 120 chars more than the assert lib.&lt;/p&gt;

&lt;p&gt;Then even though there are only two fixtures a table test and deep equals was tried&amp;hellip;&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/danmux/8e4e727ac36dcada592c882cd2384e9a.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&amp;hellip;35 lines and 643 chars typed - yay we saved 3 chars! of course the table approach starts to pay off with more fixtures.&lt;/p&gt;

&lt;p&gt;The same test with a small local helper assert function&amp;hellip;&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/danmux/c805910f0727698581696f6e715843c0.js&#34;&gt;&lt;/script&gt; 

&lt;p&gt;&amp;hellip;Only 30 lines but more typing - the assert lib uses the correct line number, in this test our failures would all come from line 7 so we have to add the &lt;code&gt;valid&lt;/code&gt; and &lt;code&gt;invalid&lt;/code&gt; words so it is clear where the failure is from thereby adding to the character count. Hence: 708 chars typed, without them it would be closer to 650 chars.&lt;/p&gt;

&lt;p&gt;You may end up writing or dare I say C&amp;amp;P-ing this and similar helpers many times for good readability, and with little harm.&lt;/p&gt;

&lt;p&gt;Written again with the comparisons factored into its own helper&amp;hellip;&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/danmux/e7fe6c833a784a94200f463ac197ca29.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&amp;hellip;Now it is down to 28 lines and 637 chars, the lowest line and char count of all the contenders.&lt;/p&gt;

&lt;p&gt;In all &amp;lsquo;none assertion&amp;rsquo; cases the number of characters needed is more, but trivially so - and are a constant offset, not linear, adding more fixtures does not grow the delta between assertion and none assertion (assuming that the assertion based test also migrates to using tables as well). The delta can grow as more things are being tested.&lt;/p&gt;

&lt;p&gt;All the above tests are imperfect and can be pared down or improved but it is enough to provide a comparison to discuss.&lt;/p&gt;

&lt;p&gt;Although as the number of fixtures increase the table and larger local helper may be the best approach for this simple case the implicit test is probably the best because the failures are reported at the line numbers of the &lt;code&gt;t.Error&lt;/code&gt; so for the few extra chars the helpers are not worth it.&lt;/p&gt;

&lt;h2 id=&#34;the-implications&#34;&gt;The Implications&lt;/h2&gt;

&lt;p&gt;An essential function of tests is to help document the thing under test, some approaches to testing can reduce this documentation effect, but in this case the assertion lib does not overly abstract or otherwise hide the real function under test - so as documentation it is ok.&lt;/p&gt;

&lt;p&gt;It does need concerted effort to structure and write clear tests in go test to accomplish a comparable succinctness - but this is a good thing.&lt;/p&gt;

&lt;p&gt;The assertion style is (very slightly) more concise.&lt;/p&gt;

&lt;p&gt;But at what cost.&lt;/p&gt;

&lt;h3 id=&#34;indirection-and-gotchas&#34;&gt;Indirection and Gotchas&lt;/h3&gt;

&lt;p&gt;The functional indirection is also present in our local test helper cases but the helper is &lt;em&gt;local&lt;/em&gt; - its right there in the code and is a few very easily understood lines, and the arguments are typed.&lt;/p&gt;

&lt;p&gt;There is another semantic indirection in the assertion lib, something of a mini DSL to learn:&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Equals&lt;/code&gt; and &lt;code&gt;Nil&lt;/code&gt;, &lt;code&gt;NotNil&lt;/code&gt; are in another package and we make assumptions based on their naming&lt;/p&gt;

&lt;p&gt;I think it is a mistake to remove type safety from a unit test (I feel &lt;em&gt;somewhat&lt;/em&gt; differently about testing some across the wire API&amp;rsquo;s)&lt;/p&gt;

&lt;p&gt;You have to know and think about the &lt;code&gt;Equals&lt;/code&gt; having type checking entirely removed. The following should never both pass, but they do:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;assert.Equal(t,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;iban.Bban,&lt;/span&gt; &lt;span style=&#34;color: #ed9d13&#34;&gt;&amp;quot;123&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color: #d0d0d0&#34;&gt;assert.Equal(t,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;iban.Bban,&lt;/span&gt; &lt;span style=&#34;color: #3677a9&#34;&gt;123&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You may well know of another equality assertion in your favorite library that does type checking as well - but I expect that is only at runtime. There is considerable value in failing during compilation (more on the DSL later).&lt;/p&gt;

&lt;p&gt;Pointer equality is another unnecessarily introduced gotcha:&lt;/p&gt;

&lt;p&gt;e.g. this testify issue&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/stretchr/testify/issues/296&#34;&gt;https://github.com/stretchr/testify/issues/296&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hi Rob,&lt;/p&gt;

&lt;p&gt;It should be applicable to all pointers.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;NotEqual&lt;/code&gt; is comparing the values the pointers point to, rather than the
pointer addresses.&lt;/p&gt;

&lt;p&gt;We must make that clear in the docs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This issue was closed with &lt;strong&gt;clearer documentation&lt;/strong&gt;. So to understand how and when to use NotEqual you have to carefully read the documentation or inspect the code. The fundamentals of the issue captured more succinctly in this snippet.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://play.golang.org/p/QA6WK4aNfA&#34;&gt;https://play.golang.org/p/QA6WK4aNfA&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Something naturally avoided in explicit comparison.&lt;/p&gt;

&lt;p&gt;These &lt;code&gt;Equals&lt;/code&gt; and friends add another thing to learn for us and for every new engineer for ever more, and it is just another thing to be tripped up by, and then it does not solve the testing debate completely. In fact it creates its own new debate: the &amp;ldquo;I prefer x over y lib/framework&amp;rdquo; debate. Which DSL is best?&lt;/p&gt;

&lt;h3 id=&#34;the-not-so-mini-dsl-https-en-wikipedia-org-wiki-domain-specific-language&#34;&gt;The (not so) Mini &lt;a href=&#34;https://en.wikipedia.org/wiki/Domain-specific_language&#34;&gt;DSL&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Equality never looked so complicated. What follows are some public API functions from testify:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// ObjectsAreEqual determines if two objects are considered equal.&lt;/span&gt;
&lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;//&lt;/span&gt;
&lt;span style=&#34;color: #999999; font-style: italic&#34;&gt;// This function does no assertion of any kind.&lt;/span&gt;
&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;ObjectsAreEqual(expected,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;actual&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;interface&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;{})&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;(btw what does the comment &amp;ldquo;This function does no assertion of any kind.&amp;rdquo; mean)&lt;/p&gt;

&lt;p&gt;Then there are the following&amp;hellip;&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;ObjectsAreEqualValues(expected,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;actual&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;interface&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;{})&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;

&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;EqualValues(t&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;TestingT,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;expected,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;actual&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;interface&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;{},&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;msgAndArgs&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;interface&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;{})&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;

&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;Exactly(t&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;TestingT,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;expected,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;actual&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;interface&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;{},&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;msgAndArgs&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;interface&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;{})&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;

&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;Equal(t&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;TestingT,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;expected,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;actual&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;interface&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;{},&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;msgAndArgs&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;interface&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;{})&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and then why is this &amp;hellip;&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;NotEqual(t&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;TestingT,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;expected,&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;actual&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;interface&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;{},&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;msgAndArgs&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;interface&lt;/span&gt;&lt;span style=&#34;color: #d0d0d0&#34;&gt;{})&lt;/span&gt; &lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;{&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;different from &lt;code&gt;!Equal(...&lt;/code&gt; ?&lt;/p&gt;

&lt;p&gt;Testify is one of the more simple libraries - with a smaller DSL to learn, but there is still a reasonable amount of explicit knowledge needed to not get tripped up.&lt;/p&gt;

&lt;p&gt;Take a look at another larger one&amp;hellip; &lt;a href=&#34;http://goconvey.co/&#34;&gt;GoConvey&lt;/a&gt; who prodly announce&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Expressive DSL&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;What will happen when you write:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;So(x, ShouldAlmostEqual, 2)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;p&gt;&lt;code&gt;So(y, ShouldNotResemble, 2)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Here are all the other assertions we need to learn to become effective&amp;hellip;&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #202020&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #6ab825; font-weight: bold&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;(&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldEqual&lt;/span&gt;          &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldEqual&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotEqual&lt;/span&gt;       &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotEqual&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldAlmostEqual&lt;/span&gt;    &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldAlmostEqual&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotAlmostEqual&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotAlmostEqual&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldResemble&lt;/span&gt;       &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldResemble&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotResemble&lt;/span&gt;    &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotResemble&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldPointTo&lt;/span&gt;        &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldPointTo&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotPointTo&lt;/span&gt;     &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotPointTo&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldBeNil&lt;/span&gt;          &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldBeNil&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotBeNil&lt;/span&gt;       &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotBeNil&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldBeTrue&lt;/span&gt;         &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldBeTrue&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldBeFalse&lt;/span&gt;        &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldBeFalse&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldBeZeroValue&lt;/span&gt;    &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldBeZeroValue&lt;/span&gt;

	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldBeGreaterThan&lt;/span&gt;          &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldBeGreaterThan&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldBeGreaterThanOrEqualTo&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldBeGreaterThanOrEqualTo&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldBeLessThan&lt;/span&gt;             &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldBeLessThan&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldBeLessThanOrEqualTo&lt;/span&gt;    &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldBeLessThanOrEqualTo&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldBeBetween&lt;/span&gt;              &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldBeBetween&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotBeBetween&lt;/span&gt;           &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotBeBetween&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldBeBetweenOrEqual&lt;/span&gt;       &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldBeBetweenOrEqual&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotBeBetweenOrEqual&lt;/span&gt;    &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotBeBetweenOrEqual&lt;/span&gt;

	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldContain&lt;/span&gt;       &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldContain&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotContain&lt;/span&gt;    &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotContain&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldContainKey&lt;/span&gt;    &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldContainKey&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotContainKey&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotContainKey&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldBeIn&lt;/span&gt;          &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldBeIn&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotBeIn&lt;/span&gt;       &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotBeIn&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldBeEmpty&lt;/span&gt;       &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldBeEmpty&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotBeEmpty&lt;/span&gt;    &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotBeEmpty&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldHaveLength&lt;/span&gt;    &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldHaveLength&lt;/span&gt;

	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldStartWith&lt;/span&gt;           &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldStartWith&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotStartWith&lt;/span&gt;        &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotStartWith&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldEndWith&lt;/span&gt;             &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldEndWith&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotEndWith&lt;/span&gt;          &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotEndWith&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldBeBlank&lt;/span&gt;             &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldBeBlank&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotBeBlank&lt;/span&gt;          &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotBeBlank&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldContainSubstring&lt;/span&gt;    &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldContainSubstring&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotContainSubstring&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotContainSubstring&lt;/span&gt;

	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldPanic&lt;/span&gt;        &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldPanic&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotPanic&lt;/span&gt;     &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotPanic&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldPanicWith&lt;/span&gt;    &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldPanicWith&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotPanicWith&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotPanicWith&lt;/span&gt;

	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldHaveSameTypeAs&lt;/span&gt;    &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldHaveSameTypeAs&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotHaveSameTypeAs&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotHaveSameTypeAs&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldImplement&lt;/span&gt;         &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldImplement&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotImplement&lt;/span&gt;      &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotImplement&lt;/span&gt;

	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldHappenBefore&lt;/span&gt;         &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldHappenBefore&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldHappenOnOrBefore&lt;/span&gt;     &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldHappenOnOrBefore&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldHappenAfter&lt;/span&gt;          &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldHappenAfter&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldHappenOnOrAfter&lt;/span&gt;      &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldHappenOnOrAfter&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldHappenBetween&lt;/span&gt;        &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldHappenBetween&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldHappenOnOrBetween&lt;/span&gt;    &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldHappenOnOrBetween&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotHappenOnOrBetween&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotHappenOnOrBetween&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldHappenWithin&lt;/span&gt;         &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldHappenWithin&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldNotHappenWithin&lt;/span&gt;      &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldNotHappenWithin&lt;/span&gt;
	&lt;span style=&#34;color: #d0d0d0&#34;&gt;ShouldBeChronological&lt;/span&gt;      &lt;span style=&#34;color: #d0d0d0&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #d0d0d0&#34;&gt;assertions.ShouldBeChronological&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Dependencies don&amp;rsquo;t come for free.&lt;/p&gt;

&lt;p&gt;GoConvey only clocks in at 8300 lines, but its assertion package will introduce a further 26,000 lines (including a number of test libraries by Aaron Jacobs).&lt;/p&gt;

&lt;p&gt;The code extracted from testify just to support &lt;code&gt;Equals&lt;/code&gt; is 323 lines and 8200 characters, the full package adds 14,000 lines and exports 80 functions.&lt;/p&gt;

&lt;p&gt;One of the larger libraries used by the &lt;a href=&#34;https://github.com/onsi/ginkgo&#34;&gt;Ginkgo&lt;/a&gt; framework is &lt;a href=&#34;https://onsi.github.io/gomega/&#34;&gt;Gomega&lt;/a&gt; it has 1500 lines of documentation and just under 12,000 lines, Ginkgo has 20,000 lines - these counts don&amp;rsquo;t include any other dependencies.&lt;/p&gt;

&lt;p&gt;(for clarity: &lt;em&gt;&amp;ldquo;lines&amp;rdquo;&lt;/em&gt; is lines in all go files using the naive &lt;code&gt;find . -name &#39;*.go&#39; | xargs wc -l&lt;/code&gt; simply to get a sense of scale)&lt;/p&gt;

&lt;p&gt;The one thing these libs have in common is bugs. It is annoying enough to have to debug test code, let alone 3rd party test support libraries.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Hopefully this post demonstrates that the value these assertion libs add is, at least, arguable and also details some of the complexities they add in exchange. As much as the arguments for an assertion lib are clear, perhaps this has helped tip the balance in favour of the stdlib approach.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;No doubt assertion libs can reduce typing and repetition.&lt;/li&gt;
&lt;li&gt;Reductions in typing with assertion libs are not profound.&lt;/li&gt;
&lt;li&gt;The necessary repetition without assertion libs can be minimised.&lt;/li&gt;
&lt;li&gt;Some repetition locally can increase readability at no great cost.&lt;/li&gt;
&lt;li&gt;There is a burden of extra care in writing plain go tests - arguably a good thing.&lt;/li&gt;
&lt;li&gt;Type safety is often dropped - or needs explicit knowledge, or is only enforced at runtime.&lt;/li&gt;
&lt;li&gt;Pointers vs value comparisons can easily trip up the unwary.&lt;/li&gt;
&lt;li&gt;There is a DSL to learn - often considerable - an extra burden on the team and new members forever.&lt;/li&gt;
&lt;li&gt;The libs often introduce multiple ways to achieve the same thing, or worse: similar but subtly different ways.&lt;/li&gt;
&lt;li&gt;It does not resolve the infighting - a new dev will argue for their favourite lib.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Adding the assertion lib in the middle of a project adds an annoying inconsistency.&lt;/li&gt;
&lt;li&gt;Some assertion libs tend to reduce the value of tests as documentation.&lt;/li&gt;
&lt;li&gt;You are adding another (often large) library dependency with associated maintenance overhead, bugs, life cycle etc.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;It is a commitment that will stay with you for a long time, and it is expensive to undo.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I agree that not only is the discussion bike-shedding it appears to follow &lt;a href=&#34;https://en.wikipedia.org/wiki/Sayre%27s_law&#34;&gt;Sayre&amp;rsquo;s law&lt;/a&gt; (both this and the law of triviality I think are forms of availability bias, which I have &lt;a href=&#34;http://danmux.com/posts/test_pyramid_availability_bias/&#34;&gt;written about in the context of unit tests&lt;/a&gt;) and we should stay focussed on the bigger challenges.&lt;/p&gt;

&lt;p&gt;If I were to work with a team that has aligned on assertions in their testing, then I would, with some sadness, accept it and move on to things that really matter.&lt;/p&gt;

&lt;p&gt;The only value I can see in accepting an assertion library into an established stdlib only unit tests codebase is that like us, you have probably wasted many person-days discussing this. We certainly redo the same discussion for many new team members. If only I was convinced adding one of these libs would end the discussion, then I might agree to it (for the wrong reasons).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DRY&lt;/strong&gt; does not only apply to code. Next time I will point them at this, and hope it helps.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>What Golang Is and Is Not</title>
      <link>http://danmux.com/posts/what_golang_isnt/</link>
      <pubDate>Wed, 17 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://danmux.com/posts/what_golang_isnt/</guid>
      <description>&lt;p&gt;We are all products of our own histories, and I suspect many routes to Go have been made less enjoyable by misguided expectations. The journey from when a budding developer first ‘hello worlded’ to now may have made Go’s more subtle strengths less obvious to them.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Go is least of all about the language in and of itself, but rather about the broader things affected by it, more so than other languages I have used over the years.&lt;/p&gt;

&lt;p&gt;Many recent arrivals to Go have preconceptions that have been proved wrong and caused disappointment, this appears to happen most often when looking from a more purist computer science based language design point of view.&lt;/p&gt;

&lt;p&gt;Go is an engineering tool, in a much broader sense. To appreciate it properly I think you have to have spent a decent amount of time responsible for the full lifecycle. If all you ever do is write and commit code then much of Go will be lost on you.&lt;/p&gt;

&lt;h2 id=&#34;the-go-hype-or-not&#34;&gt;The Go Hype, or Not.&lt;/h2&gt;

&lt;p&gt;I have heard more than once that people have been disappointed by go given the hype surrounding it. I don’t remember anything really hype like 5 years ago when go was in its infancy, and I must say that I am not really aware of anything specific now. Of course any new language that is becoming better adopted, in particular as quickly as Go, will naturally attract attention.&lt;/p&gt;

&lt;p&gt;There are articles out there that sing Go’s praises, perhaps a little too highly, but I don’t remember many of them explicitly making any claims about the language itself being the reason why Go is so good.&lt;/p&gt;

&lt;h2 id=&#34;go-is-not-an-innovative-language&#34;&gt;Go is Not An Innovative Language&lt;/h2&gt;

&lt;p&gt;“Innovative” is such an overused and abused word that it has lost a lot of power and meaning. All innovation is contextual and to use the word without context is foolhardy. In the context of language design Go was never an innovative language, nor was it presented as such, or anyone dishonest in representing it that way.&lt;/p&gt;

&lt;p&gt;As a language Go was always explicitly a return to simplicity, and in many ways naivety, for sound reasons.&lt;/p&gt;

&lt;p&gt;“There is nothing new under the sun” rings true in all languages since the 80’s. Virtually everything we see in language design now that someone says is “innovative” has been explored in some form before. Go is certainly no exception, but remember it never claimed to be state of the art.&lt;/p&gt;

&lt;p&gt;Regarding the language being youthful, of course it is, but the intention is not for the language itself to ‘mature’: no more complexity is going to be added, or at least it’s very unlikely. It is not ‘missing’ comprehensions, or inheritance, or generics, they are &lt;strong&gt;omitted&lt;/strong&gt; (and I pray, always will be). In some way, in the context of the current fashion of returning to more functional languages, or the evolution of good old languages to include more functional paradigms (I’m looking at you Javascript and Python for two examples) then in a tenuous convoluted way Go has ‘innovated’ by avoiding that trend.&lt;/p&gt;

&lt;h2 id=&#34;go-is-an-innovative-thing&#34;&gt;Go is an Innovative Thing&lt;/h2&gt;

&lt;p&gt;It is hard to define what the ‘thing’ is, but it is quite a broad thing, I can’t fully say it is an approach, or a belief, or even ‘patterns and practices’, though that last phrase feels closest. This is still about the best read on the subject: &lt;a href=&#34;https://talks.golang.org/2012/splash.article&#34;&gt;Go at Google: Language Design in the Service of Software Engineering&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Possibly Go’s greatest ‘innovation’ is to eschew making software engineering an overly academic process in daily practice, and to focus on improving the tools, speed, reliability and pure pleasure in &lt;strong&gt;delivering&lt;/strong&gt; and running things of value.&lt;/p&gt;

&lt;p&gt;Thats not to say that Go encourages you hack away without a sound foundation, quite the opposite, I think Go almost &lt;em&gt;requires&lt;/em&gt; you to have a good grasp of the fundamentals, to be an effective Go programmer. I would say that the simplicity and imperative style that Go encourages, tends to demand a greater underlying computer science knowledge than many other languages may expect. Having recently watched &lt;a href=&#34;https://www.youtube.com/watch?v=ClPIeuL9HnI&#34;&gt;Mind the Gap (GopherCon 2016)&lt;/a&gt; I think Katrina Owen echo’s this belief.&lt;/p&gt;

&lt;h3 id=&#34;unifying&#34;&gt;Unifying&lt;/h3&gt;

&lt;p&gt;I think one reasonable way of categorising all the things that make up delivering software products is into: &lt;em&gt;human, operational and technology&lt;/em&gt; factors, in that order of value. Go helps address some problems in all three areas but it is its influence over human and operational factors where it sets itself apart from other systems.&lt;/p&gt;

&lt;p&gt;Even as technologists we can’t help moving things into the ‘human’ domains such as emotion and personalisation, most compilers don’t care about many of the things humans care about, but the language naturally becomes a very human thing.&lt;/p&gt;

&lt;p&gt;Go has learned from the experience of fractured communities and continual in-fighting amongst teams and has attempted to avoid debates that continue to rage in other languages that are 20+ years old. The early focus on idioms helped that. This approach comes from years of experience delivering in teams at scale, where the language is one small factor, which has caused an inappropriate amount of time wasted on a tiny fraction of the whole value. As an example: curly brace positioning is one of the most trivial things possible, and yet still many hours are wasted on it.&lt;/p&gt;

&lt;h3 id=&#34;paradox-of-choice&#34;&gt;Paradox of Choice&lt;/h3&gt;

&lt;p&gt;In all languages there are always some basic primitives and data types that relate closely to the machine instruction set, which in turns map well to the hardware (see &lt;a href=&#34;http://danmux.com/posts/what_golang_isnt#note-1&#34;&gt;Note 1.&lt;/a&gt;) Ultimately all other higher order data structures in all languages are composed of arrays, references, and structs. Trees, heaps, sets, queues and everything else effectively only manipulate arrays of structs/primitives or self referencing structs, thats it, simple, or it should be.&lt;/p&gt;

&lt;p&gt;In the Go language at its heart that simplicity is encouraged, we are only offered some basics. To start with we are given primitives, structs and arrays, then because it is unavoidably useful we have a dynamic array, a &lt;code&gt;Slice&lt;/code&gt; which is an embellished array to allow dynamic resizing. Finally, in certain problem domains the power and flexibility of a hash-map is also unavoidable, therefore Go provides a &lt;code&gt;Map&lt;/code&gt; built in. These are given some special treatment, simply because it is very useful and they are special, (providing the same treatment to function returns would add low value complexity)&lt;/p&gt;

&lt;p&gt;There is a subtlety to providing only this subset. The fact they map well to lower layers imbues an immediate sense of being more intimate with the CPU, which certainly for ‘older’ engineers feels refreshing, and at a minimum for younger engineers tends to influence design decisions towards simplicity. Having said that the desire to construct complex implementations of data structures - even if used only once - is ever present when a new arrival to Go finds their favourite container is ‘missing’.&lt;/p&gt;

&lt;p&gt;To provide any solution in Go that needs a dynamic data structure you can choose between hand rolled linked structures or a &lt;code&gt;Slice&lt;/code&gt; or &lt;code&gt;Map&lt;/code&gt; (or compose with them). As they are quite different the choice is normally obvious. Contrast this to the choice between map, set, hashset, bag etc etc, or rolling your own in a language that makes this a lot harder. Often the author actually only uses a subset of the functionality of those data structures. In these cases the choice becomes much less simple, indeed often a point of confusion and contention and can be the cause of further low-value conversations.&lt;/p&gt;

&lt;p&gt;A Go programmer takes a slice or map and mixes in a few functions to provide the structure they need. For example The Go standard library has provided a minimal &lt;code&gt;container&lt;/code&gt; package with a &lt;code&gt;heap&lt;/code&gt; (which is just an interface), a &lt;code&gt;list&lt;/code&gt; (doubly linked), and a &lt;code&gt;ring&lt;/code&gt; (which is a closed doubly linked list). To implement a heap - you need to provide a builtin to implement the storage with an array being the typical choice.&lt;/p&gt;

&lt;p&gt;Each one of those packages has no more than around 200 lines of code. Those few lines of code are very readable, the behaviour understandable, and the performance predictable; being a function of the performance of the well understood builtin and the users own implementation code.&lt;/p&gt;

&lt;p&gt;This removal of choice and focus on reusing the two builtins, drives a readability, clarity and consistency amongst Go programmers, not afforded in other languages.&lt;/p&gt;

&lt;p&gt;In other languages an iterator (one of the often complained about omissions) necessarily abstracts that which is being contained, and often insists on a broad interface some of which then remains unused, and adds some cognitive load, sometimes unnecessarily. Not providing an iterator and not providing many containers implementing iterable, or whatever other system, avoids needing a whole swathe of knowledge, indirection, discussion and misunderstanding, at little practical cost.&lt;/p&gt;

&lt;p&gt;The effect of the omission in real world code results in minimal extra work at code creation time, for great gains in the rest of the lifecycle. Custom data structures can be composed from the well understood builtins, rolled in under 100 lines of code and can can exist close to the place they are used (yes repeated!). The effect of this approach on readability, maintainability, decoupling, removing seemingly endless low value conversations, and when push comes to shove the ability to understand performance characteristics and then tune them, adds so much more value to the whole lifecycle, than the cost of the omission.&lt;/p&gt;

&lt;p&gt;These are subtle yet important factors that attempt to address some of the human and operational complications.&lt;/p&gt;

&lt;h2 id=&#34;more-than-a-language&#34;&gt;More Than a Language&lt;/h2&gt;

&lt;p&gt;Without going into all of the things that the Go ecosystem brings to the table on top of the language design, what should be clear from a shallow familiarity with the tooling is that Go has focussed on providing answers to some of the more difficult aspects of actually getting code that is both stable and agile into production. These things that were part of Go from the beginning have had to evolve over decades in other languages, often in fractured directions - again adding the paradox of choice. For example Go’s dependency management attempts to solve a thorny problem, and while &lt;code&gt;go get&lt;/code&gt; in particular is going through some teething pains, its inclusion from day one is illustrative of Go’s intention.&lt;/p&gt;

&lt;p&gt;It is this focus on the operational aspects of development, so early on in Go’s evolution that emphasises the reason Go was created, and is commonly overlooked in favour of low value critiques of the language itself.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;note-1&#34;&gt;Note 1.&lt;/h2&gt;

&lt;p&gt;In our Von Neumann / Harvard world we have basically three hardwired data structures, a register, a stack, and addressable memory, these are mapped via the instruction set to: register operations; effectively push and pop, moving data to and from memory addresses, and in CISC’s contiguous memory operations, even in RISC’s loop primitives are optimised for contiguous ranges. Ultimately these in turn map through compilers to value variables (which indirect the decision to use registers, the stack, or an addressable value), and reference variables, which contain the value of an address of the value, and slightly higher up the conceptual scale: arrays. Compilers also compose these fundamental variables into primitive data types: ints, floats, and arrays into strings etc. Finally, also through well managed contiguous memory, namely ‘packing’, common primitives are grouped into ‘structs’. There are subtle variations on these themes, particularly with respect to structs or objects, involving further indirection (think v-tables etc), but that is the crux of it.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>JSON, Gzip, Snappy and Gob Across the Wire</title>
      <link>http://danmux.com/posts/across_the_wire_serialisation/</link>
      <pubDate>Sun, 21 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://danmux.com/posts/across_the_wire_serialisation/</guid>
      <description>&lt;p&gt;Coming from a background where memory and clock cycles were sparse, binary encodings have always held an appeal. Since then I’ve been told we have loads of compute power, ample cheap RAM and disk, and when the network is the bottleneck then, well, that is a good problem to have.&lt;/p&gt;

&lt;p&gt;Its one of those ages old occasionally heated debates&amp;hellip;.&lt;/p&gt;

&lt;p&gt;(&lt;em&gt;tl;dr&lt;/em&gt; almost always use gzipped JSON)&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;serialising-for-wire-and-disk&#34;&gt;Serialising for Wire and Disk&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Much better to use a more debuggable human readable encoding and compress it in flight during transmission or storage&lt;/strong&gt;, after all browsers have native support and the performance benefits of binary formats are negligible. This is the crux of the argument for those in favour of verbose text based serialisations.&lt;/p&gt;

&lt;p&gt;I understand the argument and &lt;strong&gt;this is almost always sound advice&lt;/strong&gt;, so why doesn’t Memcache do it, why do all NoSql and NewSql implementations offer a binary alternative if not &lt;em&gt;only&lt;/em&gt; a binary inerface? Why does Thrift thrive, and MessagePack pack a punch :p ?&lt;/p&gt;

&lt;p&gt;Is it faster, or is it just cooler to do some binary stuff? - ‘Intellectual masturbation’ as an old learned colleague delightfully coined it. Or is there really a compelling use case for these things.&lt;/p&gt;

&lt;p&gt;Heres a &lt;a href=&#34;https://groups.google.com/forum/#!topic/golang-nuts/xtXh0yWOens&#34;&gt;recent example of the debate&lt;/a&gt; with all the typical (valid) points being trotted out&lt;/p&gt;

&lt;h2 id=&#34;in-this-case&#34;&gt;In This Case&amp;hellip;&lt;/h2&gt;

&lt;p&gt;Having just built a nicely homogenous #golang rpc microservices framework (or ‘milliservices’ as &lt;a href=&#34;https://twitter.com/iand/status/510090898269831170&#34;&gt;Ian Davis called his&lt;/a&gt;) I was naturally drawn to the native RPC gob encoding, but I hedged my bets and did the second worst of both worlds a gob based RPC envelope - with a []byte payload that could carry any serialisation - a la http. (the absolute worst would be http, with a gob body)&lt;/p&gt;

&lt;p&gt;The point of this ‘neither one nor the other’ design was that much like HTTP the envelope is standard so all our components can speak the same language, output consistent log data and generally behave in a more homogenous way than you typically find in a mixed bag of microservices - what you put in the message payload is down to you and your services, of course for our internal systems gob is the natural choice for the payload as well.&lt;/p&gt;

&lt;h2 id=&#34;some-trivial-calculations&#34;&gt;Some Trivial Calculations&lt;/h2&gt;

&lt;p&gt;I did some initial calculations and benchmarking comparing gzipped JSON to ‘snappy’ JSON to raw gob. I suppose it would be useful to include lz4, but as far as I can tell snappy is not a million miles different.&lt;/p&gt;

&lt;p&gt;The data is a pretty tabular in format being lists of (300 ish) financial transactions, so naturally this does not favour normal JSON which repeats the ‘column’ names, however compressing virtually removes this disadvantage.&lt;/p&gt;

&lt;p&gt;The original data contained mainly text data, which does not favour binary.&lt;/p&gt;

&lt;p&gt;I understand that without the example data and code this is unscientific, as it is impossible to reproduce, and therefore can be read only as a hint of what the truth may be. If there were any more interest than myself making notes for me then I could do a proper job later.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Raw Gob&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Raw Json&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Gzipped Json&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Snappied Json&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Size  (bytes)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;72111&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;252512&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;27115&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;47271&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Size (xGob)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3.5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.38 (/2.66)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.66 (/1.53)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Decode Speed  (ns/op)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1453910&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1750450&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3557621&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3011828&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Decode Speed (xGob)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.83 (/1.2)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.41 (/2.45)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.48 (/2.07)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;em&gt;xGob = multiplier of the Gob figure&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This data is for the payload or body only, whic relates to storage size (minus keys and indexes).&lt;/p&gt;

&lt;p&gt;If HTTP is used as the transport protocol then the average 300-500 bytes of HTTP header should be taken into account when considering bandwidth, though with internal systems this would be more like 100-200 bytes.&lt;/p&gt;

&lt;p&gt;Header size becomes a profound factor when transporting small payloads, making TCP a smarter choice, but then introducing similar debugging issues as faced with binary encodings.&lt;/p&gt;

&lt;p&gt;Our internal gob header is typically 40-50 bytes (mainly being the 36 byte text representation of &lt;a href=&#34;http://tools.ietf.org/html/rfc4122&#34;&gt;uuid&lt;/a&gt;, which would be better passed round as the raw 16 bytes)&lt;/p&gt;

&lt;p&gt;For a 40 byte binary payload (an array of 20 &lt;code&gt;int16&lt;/code&gt;&amp;rsquo;s for example) HTTP could easily cost 10x more bandwidth than TCP.&lt;/p&gt;

&lt;p&gt;The summary comparison to gob for our large data (remember this is a sub optimal use case for binary) is&amp;hellip;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Gzipped Json&lt;/td&gt;
&lt;td&gt;2.5x slower&lt;/td&gt;
&lt;td&gt;2.7x smaller&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Snappy Json&lt;/td&gt;
&lt;td&gt;2x slower&lt;/td&gt;
&lt;td&gt;1.5x smaller&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Uncompressed Json&lt;/td&gt;
&lt;td&gt;1.2x slower&lt;/td&gt;
&lt;td&gt;3.5x bigger&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;So even with binary unfriendly large text data its hard to strike a better balance than plain gob. If raw space and bandwidth were the primary concern then I would &lt;strong&gt;go for gzipped JSON over TCP&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;I’m surprised how sluggish Snappy is. Others have &lt;a href=&#34;https://groups.google.com/forum/#!topic/golang-nuts/7T1AKfDAOcQ&#34;&gt;reported&lt;/a&gt; the pure Go implementation to be quite slow.&lt;/p&gt;

&lt;p&gt;None of the decoding benchmarks streamed the data - new encoders were made every loop, I know Gob would be even faster with this optimisation, all decoders decoded into an &lt;code&gt;interface{}&lt;/code&gt;, they would all have been quicker if a particular &lt;code&gt;struct&lt;/code&gt; was used.&lt;/p&gt;

&lt;h2 id=&#34;testing-binary-payloads&#34;&gt;Testing Binary Payloads&lt;/h2&gt;

&lt;p&gt;It is tempting to emphasise the more tangible representation of test data that a browser or even a prettified curl output offers, or the ease of editing a JSON file.&lt;/p&gt;

&lt;p&gt;It is only marginally more hassle to construct test structs (or the equivalent in your own language) in unit or integration tests, and in general a better idea, and something you’ll have to do anyway.&lt;/p&gt;

&lt;p&gt;In many languages (particularly Go) writing a curl like tool to interact with a binary rpc is, admittedly a tooling up overhead, however its a pretty simple, one off days work.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;A compressed text based encoding like JSON &lt;strong&gt;is&lt;/strong&gt; more widely supported, quite compact and easier to test and debug, particularly if the consumer is a web browser.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Very few scenarios justify anything other than compressed JSON&lt;/strong&gt; (swap JSON with XML if you are stuck in that particular hell)&lt;/p&gt;

&lt;p&gt;If you are approaching or know you will approach network limitations, or will save £1000’s per month (substitute for your own acceptable budget) and want to keep response rates up then a binary format may well be the right choice for all payload sizes.&lt;/p&gt;

&lt;p&gt;If your system chatters lots of small chunks of data with a high ratio of none text to text data, at very high message rates, then a binary encoding particularly over TCP (thereby avoiding the HTTP header overhead) is by far the more sensible choice.&lt;/p&gt;

&lt;p&gt;Testing and debugging binary protocols is not as bad as people make out, and should not be a massively deciding factor.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Jmeter is a Poor Choice for REST and Golang</title>
      <link>http://danmux.com/posts/jmeter_rest_golang/</link>
      <pubDate>Sun, 06 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://danmux.com/posts/jmeter_rest_golang/</guid>
      <description>&lt;p&gt;Its essential we have good integration tests and performance tests on our restful api, particularly now that many of the moving parts will migrate to microservices written in Go.&lt;/p&gt;

&lt;p&gt;Trying to use Jmeter both to validate responses and apply reasonable load has been troublesome.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;json-requests-are-hard&#34;&gt;JSON Requests are Hard&lt;/h2&gt;

&lt;p&gt;Jmeter is crap at constructing anything but static JSON.&lt;/p&gt;

&lt;p&gt;Just a quick search uncovers &lt;a href=&#34;http://beanshell.org/&#34;&gt;Beanshell&lt;/a&gt; - and it looks like hassle.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ubik-ingenierie.com/blog/extract-JSON-content-efficiently-with-jmeter-using-JSON-path-syntax-with-ubik-load-pack/&#34;&gt;This alternative&lt;/a&gt; doesn&amp;rsquo;t look too much better.&lt;/p&gt;

&lt;h2 id=&#34;json-responses-are-hard&#34;&gt;JSON Responses are Hard&lt;/h2&gt;

&lt;p&gt;Applying meaningful assertions to the responses in Jmeter is also a bit of a ball ache - regex is the default. There is no json parsing out of the box.&lt;/p&gt;

&lt;p&gt;Plugins improve things somewhat, but modelling a flow of a couple of requests with some shared session awareness is another load of hassle.&lt;/p&gt;

&lt;h2 id=&#34;performance-is-questionable&#34;&gt;Performance is Questionable&lt;/h2&gt;

&lt;p&gt;My own experiments and the thread below shows how a single jmeter instance is probably not quick enough to test the performance of a Go based web server, without setting up a few instances - but i spose we will have to do that in production even if we do find a fast tool.&lt;/p&gt;

&lt;!-- Place this tag in your head or just before your close body tag. --&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://apis.google.com/js/plusone.js&#34;&gt;&lt;/script&gt;

&lt;!-- Place this tag where you want the widget to render. --&gt;

&lt;div class=&#34;g-post&#34; data-href=&#34;https://plus.google.com/101114877505962271216/posts/PeZk8FY3PWY&#34;&gt;&lt;/div&gt;

&lt;h2 id=&#34;alternatives&#34;&gt;Alternatives&lt;/h2&gt;

&lt;p&gt;A quick search shows&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://code.google.com/p/restty/&#34;&gt;Resty&lt;/a&gt; - not tried it, not sure it does performance testing.&lt;/p&gt;

&lt;p&gt;Others via stack overflow etc. all appear to be pretty much GUI based or GUI only&lt;/p&gt;

&lt;h2 id=&#34;next-steps&#34;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Do we build our own tests?&lt;/p&gt;

&lt;p&gt;Is there a more JSON friendly tool that can assert, pass on responses to the next step and load the service in parallel? I couldnt find anything.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://news.ycombinator.com/item?id=7995111&#34;&gt;Fancy discussing on HN&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Moving to Hugo</title>
      <link>http://danmux.com/posts/hugo_based_blog/</link>
      <pubDate>Thu, 29 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://danmux.com/posts/hugo_based_blog/</guid>
      <description>&lt;p&gt;I decided that I should blog under my danmux.com domain - I often use danmux around the internet, sometimes danmull, but normally danmux for tech type things, so it makes sense.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;danmux&lt;/strong&gt; because the &lt;strong&gt;x&lt;/strong&gt; has always been a notable part of my name - and mux reminds me of my electrical engineering days, and I think humans multiplex all the time, there it is.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;github-pages&#34;&gt;Github Pages&lt;/h2&gt;

&lt;p&gt;As this will only get a couple of hits what could be better than hosting it on &lt;a href=&#34;https://pages.github.com/&#34;&gt;github pages&lt;/a&gt; - I&amp;rsquo;m a little bit in love with github anyway so perfect choice.&lt;/p&gt;

&lt;h2 id=&#34;hugo&#34;&gt;Hugo&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m a little bit in love with go - so &lt;a href=&#34;http://hugo.spf13.com/&#34;&gt;Hugo&lt;/a&gt; was the perfect choice as well, and its been great so far, other than is typical of newish open source projects slightly lacking in the documentation department.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>